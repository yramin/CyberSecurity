"""
Vulnerability Scanner Agent for SAST, dependency scanning, and container security.
Integrates with Trivy, Bandit, Safety, and OWASP ZAP.
"""

import asyncio
import json
import logging
import os
import subprocess
from pathlib import Path
from typing import Any, Dict, List, Optional

import httpx

from core.llm_client import LLMClient
from core.rag_engine import RAGEngine

logger = logging.getLogger(__name__)


class TrivyScanner:
    """Trivy scanner for container and filesystem scanning."""

    def __init__(self, binary_path: str = "/usr/local/bin/trivy"):
        """
        Initialize Trivy scanner.

        Args:
            binary_path: Path to trivy binary
        """
        self.binary_path = binary_path

    async def scan_image(self, image_name: str, timeout: int = 300) -> Dict[str, Any]:
        """
        Scan Docker image with Trivy.

        Args:
            image_name: Docker image name
            timeout: Scan timeout in seconds

        Returns:
            Scan results
        """
        try:
            cmd = [
                self.binary_path,
                "image",
                "--format",
                "json",
                "--quiet",
                image_name,
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=timeout
            )

            if process.returncode == 0:
                result = json.loads(stdout.decode())
                return {
                    "status": "success",
                    "image": image_name,
                    "results": result,
                }
            else:
                return {
                    "status": "error",
                    "image": image_name,
                    "error": stderr.decode(),
                }

        except asyncio.TimeoutError:
            return {
                "status": "timeout",
                "image": image_name,
                "error": f"Scan timed out after {timeout} seconds",
            }
        except Exception as e:
            logger.error(f"Trivy scan failed: {str(e)}")
            return {
                "status": "error",
                "image": image_name,
                "error": str(e),
            }

    async def scan_filesystem(self, path: str, timeout: int = 300) -> Dict[str, Any]:
        """
        Scan filesystem with Trivy.

        Args:
            path: Path to scan
            timeout: Scan timeout in seconds

        Returns:
            Scan results
        """
        try:
            cmd = [
                self.binary_path,
                "fs",
                "--format",
                "json",
                "--quiet",
                path,
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=timeout
            )

            if process.returncode == 0:
                result = json.loads(stdout.decode())
                return {
                    "status": "success",
                    "path": path,
                    "results": result,
                }
            else:
                return {
                    "status": "error",
                    "path": path,
                    "error": stderr.decode(),
                }

        except asyncio.TimeoutError:
            return {
                "status": "timeout",
                "path": path,
                "error": f"Scan timed out after {timeout} seconds",
            }
        except Exception as e:
            logger.error(f"Trivy filesystem scan failed: {str(e)}")
            return {
                "status": "error",
                "path": path,
                "error": str(e),
            }


class BanditScanner:
    """Bandit scanner for Python SAST."""

    def __init__(self, severity_level: str = "medium", confidence_level: str = "medium"):
        """
        Initialize Bandit scanner.

        Args:
            severity_level: Minimum severity level (low, medium, high)
            confidence_level: Minimum confidence level (low, medium, high)
        """
        self.severity_level = severity_level
        self.confidence_level = confidence_level

    async def scan_directory(self, directory: str) -> Dict[str, Any]:
        """
        Scan Python code directory with Bandit.

        Args:
            directory: Directory to scan

        Returns:
            Scan results
        """
        try:
            cmd = [
                "bandit",
                "-r",
                directory,
                "-f",
                "json",
                "-ll",  # Low severity, low confidence (we filter later)
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=300)

            if process.returncode in [0, 1]:  # Bandit returns 1 if issues found
                result = json.loads(stdout.decode())
                # Filter by severity and confidence
                filtered_results = self._filter_results(result)
                return {
                    "status": "success",
                    "directory": directory,
                    "results": filtered_results,
                }
            else:
                return {
                    "status": "error",
                    "directory": directory,
                    "error": stderr.decode(),
                }

        except Exception as e:
            logger.error(f"Bandit scan failed: {str(e)}")
            return {
                "status": "error",
                "directory": directory,
                "error": str(e),
            }

    def _filter_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Filter results by severity and confidence."""
        severity_map = {"low": 1, "medium": 2, "high": 3}
        confidence_map = {"low": 1, "medium": 2, "high": 3}

        min_severity = severity_map.get(self.severity_level, 2)
        min_confidence = confidence_map.get(self.confidence_level, 2)

        filtered = {
            "metrics": results.get("metrics", {}),
            "results": [],
        }

        for result in results.get("results", []):
            issue_severity = severity_map.get(result.get("issue_severity", "low"), 1)
            issue_confidence = confidence_map.get(
                result.get("issue_confidence", "low"), 1
            )

            if issue_severity >= min_severity and issue_confidence >= min_confidence:
                filtered["results"].append(result)

        return filtered


class SafetyScanner:
    """Safety scanner for Python dependency vulnerabilities."""

    async def scan_requirements(self, requirements_file: str) -> Dict[str, Any]:
        """
        Scan requirements file with Safety.

        Args:
            requirements_file: Path to requirements.txt

        Returns:
            Scan results
        """
        try:
            cmd = [
                "safety",
                "check",
                "--file",
                requirements_file,
                "--json",
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=60)

            # Safety returns non-zero if vulnerabilities found
            if stdout:
                try:
                    result = json.loads(stdout.decode())
                    return {
                        "status": "success",
                        "requirements_file": requirements_file,
                        "vulnerabilities": result,
                    }
                except json.JSONDecodeError:
                    # Safety may output text if no JSON flag works
                    return {
                        "status": "success",
                        "requirements_file": requirements_file,
                        "vulnerabilities": [],
                        "output": stdout.decode(),
                    }
            else:
                return {
                    "status": "success",
                    "requirements_file": requirements_file,
                    "vulnerabilities": [],
                }

        except Exception as e:
            logger.error(f"Safety scan failed: {str(e)}")
            return {
                "status": "error",
                "requirements_file": requirements_file,
                "error": str(e),
            }


class ZAPScanner:
    """OWASP ZAP scanner for API security testing."""

    def __init__(self, api_url: str = "http://localhost:8080", api_key: Optional[str] = None):
        """
        Initialize ZAP scanner.

        Args:
            api_url: ZAP API URL
            api_key: ZAP API key
        """
        self.api_url = api_url.rstrip("/")
        self.api_key = api_key or os.getenv("ZAP_API_KEY", "")

    async def scan_url(self, target_url: str, scan_type: str = "spider") -> Dict[str, Any]:
        """
        Scan URL with ZAP.

        Args:
            target_url: URL to scan
            scan_type: Type of scan (spider, active, ajax)

        Returns:
            Scan results
        """
        if not self.api_key:
            return {
                "status": "error",
                "error": "ZAP API key not configured",
            }

        try:
            # Start scan
            params = {
                "url": target_url,
                "apikey": self.api_key,
            }

            if scan_type == "spider":
                endpoint = f"{self.api_url}/JSON/spider/action/scan/"
            elif scan_type == "active":
                endpoint = f"{self.api_url}/JSON/ascan/action/scan/"
            else:
                return {"status": "error", "error": f"Unknown scan type: {scan_type}"}

            async with httpx.AsyncClient() as client:
                response = await client.get(endpoint, params=params, timeout=30.0)
                response.raise_for_status()
                scan_result = response.json()

                scan_id = scan_result.get("scan")

                # Wait for scan to complete
                await self._wait_for_scan_completion(scan_id, scan_type)

                # Get results
                results = await self._get_scan_results(scan_id, scan_type)

                return {
                    "status": "success",
                    "target_url": target_url,
                    "scan_type": scan_type,
                    "results": results,
                }

        except Exception as e:
            logger.error(f"ZAP scan failed: {str(e)}")
            return {
                "status": "error",
                "target_url": target_url,
                "error": str(e),
            }

    async def _wait_for_scan_completion(self, scan_id: str, scan_type: str, max_wait: int = 300):
        """Wait for ZAP scan to complete."""
        endpoint_map = {
            "spider": f"{self.api_url}/JSON/spider/view/status/",
            "active": f"{self.api_url}/JSON/ascan/view/status/",
        }

        endpoint = endpoint_map.get(scan_type)
        if not endpoint:
            return

        params = {"apikey": self.api_key}

        for _ in range(max_wait):
            async with httpx.AsyncClient() as client:
                response = await client.get(endpoint, params=params, timeout=10.0)
                if response.status_code == 200:
                    status = response.json().get("status", 0)
                    if status == 100:  # Complete
                        return
            await asyncio.sleep(1)

    async def _get_scan_results(self, scan_id: str, scan_type: str) -> Dict[str, Any]:
        """Get ZAP scan results."""
        alerts_endpoint = f"{self.api_url}/JSON/core/view/alerts/"
        params = {"apikey": self.api_key, "baseurl": ""}

        async with httpx.AsyncClient() as client:
            response = await client.get(alerts_endpoint, params=params, timeout=30.0)
            if response.status_code == 200:
                return response.json()
            return {}


class VulnerabilityScannerAgent:
    """Vulnerability Scanner Agent for comprehensive security scanning."""

    def __init__(
        self,
        llm_client: Optional[LLMClient] = None,
        rag_engine: Optional[RAGEngine] = None,
        trivy_path: str = "/usr/local/bin/trivy",
        zap_url: Optional[str] = None,
        zap_api_key: Optional[str] = None,
    ):
        """
        Initialize vulnerability scanner agent.

        Args:
            llm_client: LLM client for analysis
            rag_engine: RAG engine for context
            trivy_path: Path to Trivy binary
            zap_url: OWASP ZAP API URL
            zap_api_key: OWASP ZAP API key
        """
        self.llm_client = llm_client
        self.rag_engine = rag_engine
        self.trivy = TrivyScanner(trivy_path)
        self.bandit = BanditScanner()
        self.safety = SafetyScanner()
        self.zap = ZAPScanner(zap_url or "http://localhost:8080", zap_api_key)
        self.scan_results: List[Dict[str, Any]] = []

    async def scan_docker_image(self, image_name: str) -> Dict[str, Any]:
        """
        Scan Docker image for vulnerabilities.

        Args:
            image_name: Docker image name

        Returns:
            Scan results
        """
        logger.info(f"Scanning Docker image: {image_name}")
        result = await self.trivy.scan_image(image_name)

        # Process and prioritize results
        if result["status"] == "success":
            processed = self._process_trivy_results(result)
            self.scan_results.append(processed)
            return processed

        return result

    async def scan_code_directory(self, directory: str) -> Dict[str, Any]:
        """
        Scan code directory for vulnerabilities.

        Args:
            directory: Directory to scan

        Returns:
            Scan results
        """
        logger.info(f"Scanning code directory: {directory}")

        # Run Bandit
        bandit_results = await self.bandit.scan_directory(directory)

        # Run Trivy filesystem scan
        trivy_results = await self.trivy.scan_filesystem(directory)

        # Combine results
        combined = {
            "status": "success",
            "directory": directory,
            "bandit": bandit_results,
            "trivy": trivy_results,
            "timestamp": self._get_timestamp(),
        }

        self.scan_results.append(combined)
        return combined

    async def scan_dependencies(self, requirements_file: str) -> Dict[str, Any]:
        """
        Scan Python dependencies for vulnerabilities.

        Args:
            requirements_file: Path to requirements.txt

        Returns:
            Scan results
        """
        logger.info(f"Scanning dependencies: {requirements_file}")
        result = await self.safety.scan_requirements(requirements_file)

        if result["status"] == "success":
            processed = self._process_safety_results(result)
            self.scan_results.append(processed)
            return processed

        return result

    async def scan_api(self, target_url: str) -> Dict[str, Any]:
        """
        Scan API endpoint for security issues.

        Args:
            target_url: URL to scan

        Returns:
            Scan results
        """
        logger.info(f"Scanning API: {target_url}")
        result = await self.zap.scan_url(target_url, scan_type="active")

        if result["status"] == "success":
            processed = self._process_zap_results(result)
            self.scan_results.append(processed)
            return processed

        return result

    def _process_trivy_results(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """Process and prioritize Trivy results."""
        processed = {
            "scanner": "trivy",
            "type": result.get("image") or result.get("path", "unknown"),
            "vulnerabilities": [],
            "summary": {
                "total": 0,
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
            },
            "timestamp": self._get_timestamp(),
        }

        trivy_data = result.get("results", {})
        if isinstance(trivy_data, dict):
            results = trivy_data.get("Results", [])
            for r in results:
                vulns = r.get("Vulnerabilities", [])
                for vuln in vulns:
                    severity = vuln.get("Severity", "UNKNOWN").lower()
                    processed["vulnerabilities"].append({
                        "id": vuln.get("VulnerabilityID", ""),
                        "package": vuln.get("PkgName", ""),
                        "severity": severity,
                        "title": vuln.get("Title", ""),
                        "description": vuln.get("Description", ""),
                        "cvss": vuln.get("CVSS", {}),
                    })
                    processed["summary"]["total"] += 1
                    if severity in processed["summary"]:
                        processed["summary"][severity] += 1

        return processed

    def _process_safety_results(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """Process Safety results."""
        processed = {
            "scanner": "safety",
            "type": "dependencies",
            "vulnerabilities": result.get("vulnerabilities", []),
            "summary": {
                "total": len(result.get("vulnerabilities", [])),
            },
            "timestamp": self._get_timestamp(),
        }
        return processed

    def _process_zap_results(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """Process ZAP results."""
        zap_data = result.get("results", {})
        alerts = zap_data.get("alerts", [])

        processed = {
            "scanner": "zap",
            "type": "api",
            "target_url": result.get("target_url", ""),
            "vulnerabilities": alerts,
            "summary": {
                "total": len(alerts),
                "high": len([a for a in alerts if a.get("risk") == "High"]),
                "medium": len([a for a in alerts if a.get("risk") == "Medium"]),
                "low": len([a for a in alerts if a.get("risk") == "Low"]),
            },
            "timestamp": self._get_timestamp(),
        }

        return processed

    def _get_timestamp(self) -> str:
        """Get current timestamp."""
        from datetime import datetime
        return datetime.utcnow().isoformat()

    def get_prioritized_vulnerabilities(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get prioritized list of vulnerabilities.

        Args:
            limit: Maximum number of vulnerabilities to return

        Returns:
            Prioritized vulnerabilities
        """
        all_vulns = []

        for result in self.scan_results:
            vulns = result.get("vulnerabilities", [])
            for vuln in vulns:
                severity = vuln.get("severity", "low").lower()
                risk_score = self._calculate_risk_score(vuln, severity)
                vuln["risk_score"] = risk_score
                all_vulns.append(vuln)

        # Sort by risk score (descending)
        all_vulns.sort(key=lambda x: x.get("risk_score", 0), reverse=True)

        return all_vulns[:limit]

    def _calculate_risk_score(self, vuln: Dict[str, Any], severity: str) -> float:
        """Calculate risk score for vulnerability."""
        severity_scores = {
            "critical": 1.0,
            "high": 0.8,
            "medium": 0.5,
            "low": 0.2,
        }

        base_score = severity_scores.get(severity, 0.1)

        # Adjust based on CVSS if available
        cvss = vuln.get("cvss", {})
        if isinstance(cvss, dict):
            cvss_score = cvss.get("nvd", {}).get("V3Score", 0)
            if cvss_score:
                base_score = max(base_score, cvss_score / 10.0)

        return base_score

    async def get_summary(self) -> Dict[str, Any]:
        """
        Get agent summary.

        Returns:
            Summary dictionary
        """
        total_vulns = sum(
            len(r.get("vulnerabilities", [])) for r in self.scan_results
        )

        return {
            "status": "active",
            "total_scans": len(self.scan_results),
            "total_vulnerabilities": total_vulns,
            "scanners": {
                "trivy": True,
                "bandit": True,
                "safety": True,
                "zap": bool(self.zap.api_key),
            },
        }

